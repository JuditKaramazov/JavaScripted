---
name: 7GUIs
rank: 10
tagline: 7GUIs is a programming benchmark to compare implementations in terms of their notation. 
sandboxId: 8fnwtt
previewHeight: 300px
---

import CodePreview from "../../components/CodePreview.astro";
import LessonDescription from "../../components/LessonDescription.astro";
import StaticCodeContainer from "../../components/StaticCodeContainer.astro";

<LessonDescription name={frontmatter.name}>
  7GUIs, also known as 7 Graphical User Interfaces, stand as a diligent comparison between diverse 
  approaches to GUI development. This specific benchmark defines seven tasks that represent typical 
  challenges in GUI programming; in addition, it provides a recommended set of evaluation dimensions, 
  as identifying and propagating better approaches to GUI programming (ultimately pushing programming 
  further) is not an easy task.

  In this case, we will use vanilla HTML, CSS, and JavaScript for each task - and try our best to survive 
  all of them. 
</LessonDescription>

## Table of Contents

1. [1. Counter](#1-counter)
2. [2. Temperature Converter](#2-temperature-converter)
3. [3. Flight Booker](#3-flight-booker)
4. [4. Timer](#4-timer)
5. [5. CRUD](#5-crud) 
6. [6. Circle Drawer](#6-circle-drawer)
7. [7. Cells](#7-Cells)

---

<div class="reference">

  ## 1. Counter 

  ### Challenge 

  Understanding the basic ideas of a language (or toolkit).

  ### Criteria 

  &nbsp;&nbsp;&nbsp;&nbsp;▪ Build a frame containing a <span class="font-bold">label or read-only textfield</span> and a <span class="font-bold">button</span>.
  
  &nbsp;&nbsp;&nbsp;&nbsp;▪ Initially, the <span class="font-bold">value</span> in the textfield is <span class="font-bold">0</span>.
  
  &nbsp;&nbsp;&nbsp;&nbsp;▪ Each click of the button <span class="font-bold">increases the value</span> in textfield by 1. 

  Counter serves as a gentle introduction to the basics of the language, paradigm and toolkit for one of 
  the simplest GUI applications imaginable. Thus, Counter reveals the required scaffolding and how the 
  very basic features work together to build a GUI application. A good solution will have almost no 
  scaffolding:

  <CodePreview
    sandboxId={frontmatter.sandboxId}
    previewHeight={frontmatter.previewHeight}
  />

  Although this example has been adjusted to this site's needs, here's how we could achieve a similar result 
  with plain JavaScript. 

  First, let's introduce the <span class="font-bold">HTML</span> section and its <span class="font-bold">corresponding styles</span> for a simple counter: 

  <StaticCodeContainer>

  ```html
  index.html
  ----------
  // ...

      <section id="counter">
        <h1>Counter</h1>
        <div id="body">
          <output>0</output>
          <button type="button">COUNT</button>
        </div>
      </section>

  //...
  ```

  ---

  ```css 
  styles.css
  ----------
  #counter {
  --background-color: hsl(0, 0%, 100%);
  --border-color: hsl(0, 0%, 13%);
  --shadow: 0 3px 6px hsla(0, 0%, 0%, 0.16), 0 3px 6px hsla(0, 0%, 0%, 0.23);
  --text-color: hsl(0, 0%, 13%);
  }

  section#counter {
    display: flex;
    flex-direction: column;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    box-shadow: var(--shadow);
  }

  #counter h1 {
    background: var(--text-color);
    color: var(--background-color);
    font-size: 16px;
    grid-area: top;
    text-align: center;
  }

  #counter div#body {
    display: flex;
    gap: 16px;
    padding: 16px;
  }

  #counter button {
    background: var(--text-color);
    border: none;
    color: var(--background-color);
    cursor: pointer;
    font-size: 14px;
    letter-spacing: 0.05em;
    padding: 12px 24px;
  }

  #counter output {
    border: 1px solid black;
    font-weight: 700;
    padding: 8px 16px;
  }
  ```

  </StaticCodeContainer> 

  Now, let's focus on the JavaScript part, which we'll keep as simple as the rest: 

  <StaticCodeContainer> 

  ```js
  index.js
  --------

  (function () {
    const button = document.querySelector("button");
    const output = document.querySelector("output");

    let count = 0;

    button.onclick = function () {
      count++;
      output.textContent = count;
    };
  })();

  /* 
  Keep in mind that this is just one of the ways to 
  achieve the expected result. It is not perfect, yet 
  follows the basics of the language, as well as the 
  ideas of GUI programming. 
  Your applications do not have to be obscure nor 
  complicated. For now, what matters is that the 
  desired results are accomplished. 
  */
  ```
  </StaticCodeContainer> 

  ---

  ## 2. Temperature Converter 

  ### Challenge
  
  Bidirectional data flow, user-provided text input.

  ### Criteria:

  The task is to build a frame containing 2 textfields representing the temperature in Celsius and Fahrenheit. 

  &nbsp;&nbsp;&nbsp;&nbsp;▪ Initially, <span class="font-bold">both textfields</span> are empty.

  &nbsp;&nbsp;&nbsp;&nbsp;▪ When the user enters a <span class="font-bold">numerical</span> value into a textfield, the <span class="font-bold">corresponding value in the other is automatically updated</span>. 

  &nbsp;&nbsp;&nbsp;&nbsp;▪ When the user enters a <span class="font-bold">non-numerical string</span> into a textfield, the <span class="font-bold">value in the other is not updated</span>.

  &nbsp;&nbsp;&nbsp;&nbsp;▪ Celsius to Fahrenheit formula F = C * (9/5) + 32.

  &nbsp;&nbsp;&nbsp;&nbsp;▪ Fahrenheit to Celsius formula: C = (F - 32) * (5/9).

  Temperature Converter increases the complexity of Counter by having bidirectional data flow between the Celsius 
  and Fahrenheit inputs and the need to check the user input for validity. A good solution will make the bidirectional 
  dependency <span class="font-bold">very clear with minimal boilerplate code</span>.

   <CodePreview
    sandboxId="m82ywj"
    previewHeight="400px"
  />

  Let's see what happens now when it comes to the <span class="font-bold">HTML and CSS part</span>: 

  <StaticCodeContainer> 

  ```html
  index.html
  ----------
  // ...

  <form id="tempConverter">
    <h1>Temperature Converter</h1>
      <div class="row">
        <input id="celsius" oninput="onCelsiusInput(event)" step=".01" type="number" autofocus />
        <label for="celsius">Celsius</label>&nbsp;=
        <input id="fahrenheit" oninput="onFahrenheitInput(event)" step=".01" type="number" />
        <label for="fahrenheit">Fahrenheit</label>
      </div>
  </form>

  //...
  ```

  ---

  ```css
  styles.css
  ----------

  #tempConverter {
    --background-color: hsl(0, 0%, 100%);
    --border-color: hsl(0, 0%, 13%);
    --shadow: 0 3px 6px hsla(0, 0%, 0%, 0.16), 0 3px 6px hsla(0, 0%, 0%, 0.23);
    --text-color: hsl(0, 0%, 13%);
  }

  form#tempConverter {
    display: flex;
    flex-direction: column;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    box-shadow: var(--shadow);
  }

  #tempConverter h1 {
    background: var(--text-color);
    color: var(--background-color);
    font-size: 16px;
    text-align: center;
  }

  #tempConverter div.row {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 16px;
  }

  #tempConverter label {
    cursor: pointer;
  }

  #tempConverter input {
    width: 100%;
    background: transparent;
    border: 1px solid var(--text-color);
    padding: 8px 16px;
  }
  ```

  </StaticCodeContainer>

  And the <span class="font-bold">JavaScript</span> logic behind it:

  <StaticCodeContainer>
  ```js
  index.js
  --------
  const CEL_ID = "celsius";
  const celInput = document.querySelector(`#${CEL_ID}`);
  const farInput = document.querySelector("#fahrenheit");

  function celToFar(cel) {
    return (cel * 9) / 5 + 32;
  }

  function farToCel(far) {
    return ((far - 32) * 5) / 9;
  }

  function formatVal(value) {
    return value.toFixed(2);
  }

  function changeInputVal(elem, value) {
    elem.value = formatVal(value);
  }

  function clearInput(elem) {
    elem.value = "";
  }

  function onInput(event) {
    const { value, id } = event.target;
    const otherInput = id === CEL_ID ? farInput : celInput;

    if (value === "") {
      clearInput(otherInput);
      return;
    }

    {
      const otherValue = id === CEL_ID ? celToFar(value) : farToCel(value);
      changeInputVal(otherInput, otherValue);
    }
  }

  celInput.oninput = onInput;
  farInput.oninput = onInput;
  ```
  </StaticCodeContainer>

  Now, coffee break before we keep going! 

  ---

  ## 3. Flight Booker 

  ### Challenge 

  The simplification of using textfields for date input instead of specialized date picking widgets.

  ### Criteria

  The task is to build a frame containing a <span class="font-bold">combobox with two options</span> (“one-way flight” and 
  “return flight”), <span class="font-bold">two textfields</span> representing the <span class="font-bold">start and 
  return</span> date, and a <span class="font-bold">button for submitting</span> the selected flight.

  &nbsp;&nbsp;&nbsp;&nbsp;▪ The return textfield is <span class="font-bold">enabled</span> if the combobox’s value is “return flight”.

  &nbsp;&nbsp;&nbsp;&nbsp;▪ When the “return flight” <span class="font-bold">date is strictly before time</span> or <span class="font-bold">wrong-formatted</span>, it's not possible to submit.

  &nbsp;&nbsp;&nbsp;&nbsp;▪ When submitting, <span class="font-bold">a message is displayed</span> informing the user of their selection.
  
  &nbsp;&nbsp;&nbsp;&nbsp;▪ Initially, the combobox has the <span class="font-bold">value “one-way flight”</span>, and both textfields have the same (arbitrary) date. It is implied that the return textfield is disabled.

  The focus of Flight Booker lies on modelling constraints between widgets on the one hand and modelling constraints within a 
  widget on the other hand. Such constraints are very common in everyday interactions with GUI applications, and a good solution 
  for Flight Booker will make the constraints clear, succinct and explicit in the source code, not hidden behind a lot of scaffolding.

  <CodePreview
    sandboxId="yh6xvl"
    previewHeight="550px"
  />

    Now, let’s delve into the <span class="font-bold">HTML</span> section and its <span class="font-bold">corresponding 
  styles</span>: 

  <StaticCodeContainer> 

  ```html
  index.html
  ----------
  // ...

  <form id="flightBooker">
    <h1>Flight Booker</h1>
    <div id="body">
      <label for="oneWayOrReturn">One way or return:</label>
      <select id="oneWayOrReturn">
        <option value="oneWay">one-way flight</option>
        <option value="returnFlight">return flight</option>
      </select>
      <label for="departure">Departure Date (format: DD.MM.YYYY):</label>
      <input id="departure" value="25.12.1999" />
      <label for="return">Return Date (format: DD.MM.YYYY):</label>
      <input disabled id="return" value="25.12.1999" />
      <button id="book" type="submit">BOOK</button>
    </div>
  </form>

  //...
  ```

  ---

  ```css
  styles.css
  ----------

  #flightBooker {
    --background-color: hsl(0, 0%, 100%);
    --border-color: hsl(0, 0%, 13%);
    --text-color: hsl(0, 0%, 13%);
    --shadow: 0 3px 6px hsla(0, 0%, 0%, 0.16), 0 3px 6px hsla(0, 0%, 0%, 0.23);
  }

  form#flightBooker {
    display: flex;
    flex-direction: column;
    width: 100%;
    max-width: 340px;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    box-shadow: var(--shadow);
  }

  #flightBooker h1 {
    background: var(--text-color);
    color: var(--background-color);
    font-size: 16px;
    text-align: center;
  }

  #flightBooker div#body {
    display: flex;
    flex-direction: column;
    width: 100%;
    padding: 16px;
  }

  #flightBooker label {
    font-size: 14px;
  }

  #flightBooker input,
  #flightBooker select {
    margin: 4px 0 24px 0;
    background: transparent;
    border: 1px solid var(--text-color);
    padding: 8px 16px;
  }

  #flightBooker input[aria-invalid="true"] {
    background: tomato;
  }

  #flightBooker select {
    cursor: pointer;
  }

  #flightBooker button {
    background: var(--text-color);
    border: none;
    color: var(--background-color);
    font-size: 14px;
    letter-spacing: 0.05em;
    padding: 12px 24px;
    cursor: pointer;
  }

  #flightBooker input:disabled,
  #flightBooker button:disabled {
    opacity: 0.3;
    pointer-events: none;
  }
  ```

  </StaticCodeContainer>

  Now, as for the <span class="font-bold">JavaScript part</span>, let's keep it simple:

  <StaticCodeContainer>

  ```js
  index.js
  --------
  const ARIA_INVALID = "aria-invalid";

  const oneWayOrReturnValues = {
    oneWay: "oneWay",
    returnFlight: "returnFlight",
  };

  const elems = {
    departure: document.querySelector("#departure"),
    oneWayOrReturn: document.querySelector("#oneWayOrReturn"),
    return: document.querySelector("#return"),
    book: document.querySelector("#book"),
  };

  // DOM setters.
  function setError(elem) {
    elem.setAttribute(ARIA_INVALID, true);
  }

  function clearError(elem) {
    elem.setAttribute(ARIA_INVALID, false);
  }

  function disable(elem) {
    elem.disabled = true;
  }

  function enable(elem) {
    elem.disabled = false;
  }

  function showConfirmation() {
    const message =
      elems.oneWayOrReturn.value === oneWayOrReturnValues.oneWay
        ? `You have booked a one-way flight on ${elems.departure.value}.`
        : `You have booked a return flight, departing on ${elems.departure.value} & returning on ${elems.return.value}.`;

    window.alert(message);
  }

  // Validators.
  function isOneWay() {
    return elems.oneWayOrReturn.value === oneWayOrReturnValues.oneWay;
  }

  function isValidDate(date) {
    return date instanceof Date && !isNaN(date);
  }

  function inputValueToDate(value) {
    const split = value.split(".");
    const [day, month, year] = split;

    return new Date(`${year}-${month}-${day}`);
  }

  function isBadFormat(value) {
    const split = value.split(".");

    if (split.length !== 3) return true;

    const date = inputValueToDate(value);

    return !isValidDate(date);
  }

  function isEarlyReturn() {
    const start = inputValueToDate(elems.departure.value).valueOf();
    const end = inputValueToDate(elems.return.value).valueOf();

    return end < start;
  }

  // State.
  const states = {
    oneWay: {
      badDepartureFormat: "oneWay.BadDepartureFormat",
      valid: "oneWay.valid",
    },
    returnFlight: {
      badDepartureFormat: "returnFlight.badDepartureFormat",
      badReturnFormat: "returnFlight.badReturnFormat",
      badDepartureAndReturnFormat: "returnFlight.badDepartureAndReturnFormat",
      earlyReturn: "returnFlight.earlyReturn",
      valid: "returnFlight.valid",
    },
  };

  function onStateChange(state) {
    switch (state) {
      case states.oneWay.badDepartureFormat:
        disable(elems.book);
        disable(elems.return);
        setError(elems.departure);
        clearError(elems.return);
        break;

      case states.oneWay.valid:
        enable(elems.book);
        disable(elems.return);
        clearError(elems.departure);
        clearError(elems.return);
        break;

      case states.returnFlight.badDepartureAndReturnFormat:
        disable(elems.book);
        enable(elems.return);
        setError(elems.departure);
        setError(elems.return);
        break;

      case states.returnFlight.badDepartureFormat:
        disable(elems.book);
        enable(elems.return);
        setError(elems.departure);
        clearError(elems.return);
        break;

      case states.returnFlight.badReturnFormat:
        disable(elems.book);
        enable(elems.return);
        clearError(elems.departure);
        setError(elems.return);
        break;

      case states.returnFlight.earlyReturn:
        disable(elems.book);
        enable(elems.return);
        clearError(elems.departure);
        setError(elems.return);
        break;

      case states.returnFlight.valid:
        enable(elems.book);
        enable(elems.return);
        clearError(elems.departure);
        clearError(elems.return);
        break;

      default:
        throw Error(`Unknown state: ${state}`);
    }
  }

  function calcState() {
    const isBadDepart = isBadFormat(elems.departure.value);
    const isBadReturn = isBadFormat(elems.return.value);

    if (isOneWay()) {
      return isBadDepart ? states.oneWay.badDepartureFormat : states.oneWay.valid;
    }

    if (isBadDepart && isBadReturn) {
      return states.returnFlight.badDepartureAndReturnFormat;
    }

    if (isBadDepart) {
      return states.returnFlight.badDepartureFormat;
    }

    if (isBadReturn) {
      return states.returnFlight.badReturnFormat;
    }

    if (isEarlyReturn()) {
      return states.returnFlight.earlyReturn;
    }

    return states.returnFlight.valid;
  }

  function onInputChange() {
    const state = calcState();
    onStateChange(state);
  }

  // DOM listeners.
  elems.oneWayOrReturn.onchange = onInputChange;
  elems.departure.oninput = onInputChange;
  elems.return.oninput = onInputChange;

  elems.book.onclick = function (event) {
    event.preventDefault();
    showConfirmation();
  };
  ```
  </StaticCodeContainer>

  ---

  ## 4. Timer 

  ### Challenge 

  Concurrency, competing user/signal interactions, responsiveness.

  ### Criteria

  In this case, we have to build a frame containing <span class="font-bold">a gauge for an elapsed time</span>. 
  It will incorporate:

  &nbsp;&nbsp;&nbsp;&nbsp;▪ A <span class="font-bold">label</span> which shows the elapsed time as a <span class="font-bold">numerical value</span>.

  &nbsp;&nbsp;&nbsp;&nbsp;▪ A <span class="font-bold">slider</span> by which the duration of the timer <span class="font-bold">can be adjusted while the timer is running</span>.

  &nbsp;&nbsp;&nbsp;&nbsp;▪ A <span class="font-bold">reset button</span>.

  When it comes to certain functionalities, we can't forget that:

  &nbsp;&nbsp;&nbsp;&nbsp;▪ Adjusting the slider must immediately reflect on the duration and gauge.
  
  &nbsp;&nbsp;&nbsp;&nbsp;▪ When the <span class="font-bold">elapsed time ≥ duration</span>, the timer <span class="font-bold">stops</span> (full gauge). 
  
  &nbsp;&nbsp;&nbsp;&nbsp;▪ If the duration is increased (meaning that duration > elapsed time), the timer <span class="font-bold">starts to tick until elapsed time ≥ duration again</span>.
  
  &nbsp;&nbsp;&nbsp;&nbsp;▪ Clicking the reset button will <span class="font-bold">reset the elapsed time to zero</span>.

  Timer deals with concurrency in the sense that a timer process that updates the elapsed time runs concurrently to the user's interactions 
  with the GUI application. Also, the fact that the slider adjustments must be reflected immediately tests the responsiveness of the solution, 
  forcing us to make it clear that the signal is a timer tick.

  <CodePreview
    sandboxId="g4s5s2"
    previewHeight="450px"
  />

  As always, let's try it with not much scaffolding involved. <span class="font-bold">HTML and CSS time</span>: 

  <StaticCodeContainer> 

  ```html
  index.html
  ----------
  // ...

  <section id="timer">
    <h1>Timer</h1>
    <div id="body">
      <section id="gauge">
        Elapsed Time:
        <progress value="0" max="100">0%</progress>
      </section>
      <output id="durationOutput">0s</output>
      <form>
        <div class="duration">
          <label for="durationInput">Duration:</label>
          <input id="durationInput" max="100" min="0" step="1" type="range" value="0" />
        </div>
        <button type="button">RESET</button>
      </form>
    </div>
  </section>

  //...
  ```

  ---

  ```css
  styles.css
  ----------
  #timer {
    --background-color: hsl(0, 0%, 100%);
    --border-color: hsl(0, 0%, 13%);
    --shadow: 0 3px 6px hsla(0, 0%, 0%, 0.16), 0 3px 6px hsla(0, 0%, 0%, 0.23);
    --text-color: hsl(0, 0%, 13%);
  }

  section#timer {
    display: flex;
    flex-direction: column;
    background: var(--background-color);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    box-shadow: var(--shadow);
  }

  #timer h1 {
    background: var(--text-color);
    color: var(--background-color);
    font-size: 16px;
    text-align: center;
  }

  #timer div#body {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 16px;
  }

  #timer section#gauge {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  #timer div.duration {
    display: flex;
  }

  #timer form {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  #timer input {
    flex-grow: 1;
    margin-left: 16px;
    cursor: pointer;
  }

  #timer button {
    background: var(--text-color);
    color: var(--background-color);
    border: none;
    font-size: 14px;
    letter-spacing: 0.05em;
    padding: 12px 24px;
    cursor: pointer;
  }
  ```
  </StaticCodeContainer>

  Now, let's check the <span class="font-bold">JavaScript implications</span>: 

  <StaticCodeContainer>

  ```js
  index.js
  --------
  let intervalID = null;

  const STEP_MS = 100;

  const elems = {
    durationInput: document.querySelector("#durationInput"),
    durationOutput: document.querySelector("#durationOutput"),
    progress: document.querySelector("progress"),
    reset: document.querySelector("button"),
  };

  // Displaying values.
  function setDurationDisplay() {
    const { elapsedTimeMS } = values;
    const currentValue = elems.durationOutput.textContent;
    const newValue = `${elapsedTimeMS / 1000}s`;

    if (currentValue !== newValue) {
      elems.durationOutput.textContent = newValue;
    }
  }

  function setProgressDisplay() {
    const { durationMS, elapsedTimeMS } = values;
    const currentValue = elems.progress.value;
    const newValue = durationMS === 0 ? 0 : Math.min(elapsedTimeMS / durationMS, 1) * 100;

    if (currentValue !== newValue) {
      elems.progress.value = newValue;
      elems.progress.textContent = `${newValue}%`;
    }
  }

  function setDisplayValues() {
    setDurationDisplay();
    setProgressDisplay();
  }

  // Values.
  function onValuesChange() {
    const { durationMS, elapsedTimeMS } = values;

    setDisplayValues();

    if (elapsedTimeMS >= durationMS) {
      stopTimer();
      return;
    }

    startTimer();
  }

  const values = {
    set durationMS(value) {
      this._durationMS_ = value;
      onValuesChange();
    },
    set elapseTimeMS(value) {
      this._elapsedTimeMS_ = value;
      onValuesChange();
    },
    get durationMS() {
      return this._durationMS_ || 0;
    },
    get elapsedTimeMS() {
      return this._elapsedTimeMS_ || 0;
    },
  };

  // Timer.
  function stopTimer() {
    if (intervalID) {
      clearInterval(intervalID);
      intervalID = null;
    }
  }

  function startTimer() {
    if (!intervalID) {
      intervalID = setInterval(() => {
        const { elapsedTimeMS } = values;

        values.elapseTimeMS = elapsedTimeMS + STEP_MS;
      }, STEP_MS);
    }
  }

  // DOM listeners.
  elems.durationInput.oninput = function (event) {
    const { value } = event.target;
    values.durationMS = value * 1000;
  };

  elems.reset.onclick = function () {
    values.elapseTimeMS = 0;
  };
  ```
  </StaticCodeContainer>

  ---

  ## 5. CRUD

  ### Challenge

  ### Criteria

  <CodePreview
    sandboxId="k2v2vt"
    previewHeight="600px"
  />

  ---

  ## 6. Circle Drawer 

  ### Challenge

  ### Criteria

  <CodePreview
    sandboxId="q6xmhn"
    previewHeight="620px"
  />


  ---

  ## 7. Cells 

  ### Challenge

  ### Criteria

   <CodePreview
    sandboxId="fljwpf"
    previewHeight="700px"
  />

  <div class="table-container">
  | Formula   | Example             | Description                             |
  | --------- | ------------------- | --------------------------------------- |
  | Sum       | `=SUM(B2:B3)`       | Calculates the sum of a range of cells. |
  | Subtract  | `=SUBTRACT(A2, B2)` | Subtracts one value from another.       |
  | Multiply  | `=MULTIPLY(A2, B2)` | Multiplies two values.                  |
  | Divide    | `=DIVIDE(A2, B2)`   | Divides one value by another.           |
</div>


  ---


  <StaticCodeContainer>

  </StaticCodeContainer>

</div>
